# PIE TIME

## Category 🧨: Binary Exploitation
## Difficulty 🟢: Easy
## Solves as of: October 2, 2025 — <img width="1275" height="679" alt="image" src="https://github.com/user-attachments/assets/14461eb3-0fad-4f9f-822b-7bc3979100ed" />

    Caption: This challenge has been solved by 11,229 players, indicating it is a popular challenge that many players were able to complete.
## Guide Published 📝: October 7, 2025

---

## Challenge Summary 🧩
This challenge builds intuition for [`"PIE"`](https://www.redhat.com/en/blog/position-independent-executables-pie): base addresses change every run, but the relative distance between functions remains constant. Your task is to recognize and leverage that invariant to transform a runtime address into the expected target, a core pattern for beginner binary exploitation and later offset-based techniques.

---

## Key Objective 🎯
Derive the stable `"main" − "win"` offset under `"PIE"`, then transform the service’s runtime `"main"` address into the target value it requests to obtain the flag.

---

## Prerequisites & Tools 🔧
- [`"PIE"`](https://www.redhat.com/en/blog/position-independent-executables-pie) — position-independent executables and why offsets remain constant
- [`"nc"`](https://phoenixnap.com/kb/nc-command) — to connect to the remote service (use the host/port shown on the challenge page)
- [`"gdb"`](https://www.geeksforgeeks.org/c/gdb-step-by-step-introduction/) — debugger for local inspection
- [`"disass"`](https://blog.3mdeb.com/2018/2018-04-27-the-art-of-disassembly/) — to disassemble `"main"` and `"win"`
- [`"Hex/decimal calculator"`](https://www.rapidtables.com/convert/number/hex-to-decimal.html)

---

## Walkthrough 🚀 (with WHY)

1. Connect to the remote service with `"nc"` as instructed on the challenge page and read its prompt/output carefully.
**WHY:** The service typically prints or implies a randomized `"main"` address under `"PIE"` that you must convert using a fixed offset.  
<img width="593" height="78" alt="image" src="https://github.com/user-attachments/assets/1a548f3f-d36c-4124-a704-968950ae4ea0" />
  
       Caption: Terminal shows the challenge prompt with a runtime main address to transform.

2. Download the provided source/binary from the challenge page and open the binary locally with `"gdb"`.
**WHY:** Inspecting the binary in `"gdb"` lets you obtain reliable function start addresses for computing the offset.  
<img width="2548" height="419" alt="image" src="https://github.com/user-attachments/assets/1f1d751d-4478-49c6-a66a-37ba6eb68158" />

<img width="729" height="382" alt="Screenshot 2025-10-03 105311" src="https://github.com/user-attachments/assets/c6b904d8-3db7-45dc-ad8a-bbe587d4b1d8" />
  
       Caption: gdb session opened on the challenge binary.

3. In `"gdb"`, run `"disass main"` and `"disass win"` and record the first assembly code of each function.
**WHY:** Under `"PIE"`, absolute addresses shift, but the distance between `"win"` and `"main"` is fixed for a given build.  
<img width="904" height="880" alt="Screenshot 2025-10-03 103605" src="https://github.com/user-attachments/assets/8a59183d-d203-4a89-a3cb-700ada1194d7" />
<img width="832" height="783" alt="Screenshot 2025-10-03 103755" src="https://github.com/user-attachments/assets/b8d945b8-f5f1-4e55-b790-7db88b6bc229" />
 
        Caption: Disassembly shows the starting addresses of main and win.

4. Compute the assembly code offset as (`"main"` first line) − (`"win"` first line); in my instance, this difference was **96 base 16**.
**WHY:** This constant offset is the `“key”` to map the service’s randomized `"main"` address to the expected target address.  
<img width="626" height="943" alt="image" src="https://github.com/user-attachments/assets/cc0b1a6c-9148-4910-8c96-6d7d8fa21995" />
  
       Caption: Calculator confirms the difference between the two addresses equals 96 base 16.

5. Reconnect to the service with `"nc"`, take its runtime `"main"` address, and apply the offset per the prompt’s wording (you have to subtract) to produce the value it expects, then submit that value.
**WHY:** Converting the randomized address using the stable offset defeats the address uncertainty and returns the flag.  
<img width="622" height="945" alt="image" src="https://github.com/user-attachments/assets/76e383dd-aa31-4220-860b-a9a45ef8b55e" />


<img width="641" height="145" alt="Screenshot 2025-10-03 104613" src="https://github.com/user-attachments/assets/a4800db2-732c-4616-8dc4-5fb394a665f1" />
 
       Caption: Submitting the transformed address triggers the flag output.

---

## Common Mistakes ⚠️
- Misreading the prompt and applying the offset in the wrong direction, since some texts imply “from main to win” while others imply the reverse.
- Doing arithmetic in decimal when the printed address is in hexadecimal, leading to incorrect results.
- Entering stray inputs like “x” that can cause misleading prints (e.g., a bogus difference such as “19D”) and waste time.
- Assuming an absolute address from a prior run will persist under `"PIE"` instead of relying on the relative offset.

---

## Lessons Learned ✅
- `"PIE"` randomizes absolute locations, but function-to-function offsets remain constant, enabling deterministic calculations.
- With `"gdb"` and `"disass"`, you can quickly extract function start addresses, compute a stable offset, and convert runtime addresses as required.
- Careful prompt reading and consistent hex arithmetic are just as important as the reversing steps themselves.
